package {{.PackageName}}

import (
	"fmt"
	"os"
	"strings"

	manuallexers "github.com/johnkerl/pgpg/manual/pkg/lexers"
	"github.com/johnkerl/pgpg/manual/pkg/asts"
	"github.com/johnkerl/pgpg/manual/pkg/tokens"
)

type {{.TypeName}} struct {
	Trace *{{.TypeName}}TraceHooks
}

type {{.TypeName}}TraceHooks struct {
	OnToken  func(tok *tokens.Token)
	OnAction func(state int, action {{.TypeName}}Action, lookahead *tokens.Token)
	OnStack  func(stateStack []int, nodeStack []*asts.ASTNode)
}

func New{{.TypeName}}() *{{.TypeName}} { return &{{.TypeName}}{} }

func (parser *{{.TypeName}}) Parse(lexer manuallexers.AbstractLexer) (*asts.AST, error) {
	if lexer == nil {
		return nil, fmt.Errorf("parser: nil lexer")
	}
	stateStack := []int{0}
	nodeStack := []*asts.ASTNode{}
	lookahead := lexer.Scan()
	if parser.Trace != nil && parser.Trace.OnToken != nil {
		parser.Trace.OnToken(lookahead)
	}
	for {
		if lookahead == nil {
			return nil, fmt.Errorf("parser: lexer returned nil token")
		}
		if lookahead.Type == tokens.TokenTypeError {
			return nil, fmt.Errorf("lexer error: %s", string(lookahead.Lexeme))
		}
		state := stateStack[len(stateStack)-1]
		action, ok := {{.TypeName}}Actions[state][lookahead.Type]
		if !ok {
			return nil, fmt.Errorf("parse error: unexpected %s (%q)", lookahead.Type, string(lookahead.Lexeme))
		}
		if parser.Trace != nil && parser.Trace.OnAction != nil {
			parser.Trace.OnAction(state, action, lookahead)
		}
		switch action.Kind {
		case {{.TypeName}}ActionShift:
			nodeStack = append(nodeStack, asts.NewASTNodeTerminal(lookahead, asts.NodeType(lookahead.Type)))
			stateStack = append(stateStack, action.Target)
			lookahead = lexer.Scan()
			if parser.Trace != nil && parser.Trace.OnToken != nil {
				parser.Trace.OnToken(lookahead)
			}
			if parser.Trace != nil && parser.Trace.OnStack != nil {
				parser.Trace.OnStack(stateStack, nodeStack)
			}
		case {{.TypeName}}ActionReduce:
			prod := {{.TypeName}}Productions[action.Target]
			rhsNodes := make([]*asts.ASTNode, prod.rhsCount)
			for i := prod.rhsCount - 1; i >= 0; i-- {
				stateStack = stateStack[:len(stateStack)-1]
				rhsNodes[i] = nodeStack[len(nodeStack)-1]
				nodeStack = nodeStack[:len(nodeStack)-1]
			}
{{- if eq .HintMode "hints" }}
			var node *asts.ASTNode
			if prod.hasPassthrough {
				node = rhsNodes[prod.passthroughIndex]
			} else if prod.hasHint {
				nodeType := prod.nodeType
				if nodeType == "" {
					nodeType = prod.lhs
				}
				var parentToken *tokens.Token
				if prod.parentIndex >= 0 && prod.parentIndex < len(rhsNodes) {
					parentToken = rhsNodes[prod.parentIndex].Token
				}
				hintChildren := make([]*asts.ASTNode, len(prod.childIndices))
				for i, ci := range prod.childIndices {
					hintChildren[i] = rhsNodes[ci]
				}
				node = asts.NewASTNode(parentToken, nodeType, hintChildren)
			} else if prod.rhsCount == 1 {
				node = rhsNodes[0]
			} else if prod.rhsCount == 0 {
				node = asts.NewASTNode(nil, prod.lhs, []*asts.ASTNode{})
			} else {
				node = asts.NewASTNode(nil, prod.lhs, rhsNodes)
			}
{{- else }}
			if prod.rhsCount == 0 {
				rhsNodes = []*asts.ASTNode{}
			}
			node := asts.NewASTNode(nil, prod.lhs, rhsNodes)
{{- end }}
			nodeStack = append(nodeStack, node)
			state = stateStack[len(stateStack)-1]
			nextState, ok := {{.TypeName}}Gotos[state][prod.lhs]
			if !ok {
				return nil, fmt.Errorf("parse error: missing goto for %s", prod.lhs)
			}
			stateStack = append(stateStack, nextState)
			if parser.Trace != nil && parser.Trace.OnStack != nil {
				parser.Trace.OnStack(stateStack, nodeStack)
			}
		case {{.TypeName}}ActionAccept:
			if len(nodeStack) != 1 {
				return nil, fmt.Errorf("parse error: unexpected parse stack size %d", len(nodeStack))
			}
			if parser.Trace != nil && parser.Trace.OnStack != nil {
				parser.Trace.OnStack(stateStack, nodeStack)
			}
			return asts.NewAST(nodeStack[0]), nil
		default:
			return nil, fmt.Errorf("parse error: no action")
		}
	}
}

// AttachCLITrace installs tracing hooks for CLI debugging.
func (parser *{{.TypeName}}) AttachCLITrace(traceTokens bool, traceStates bool, traceStack bool) {
	if !traceTokens && !traceStates && !traceStack {
		return
	}
	parser.Trace = &{{.TypeName}}TraceHooks{
		OnToken: func(tok *tokens.Token) {
			if !traceTokens {
				return
			}
			fmt.Fprintln(os.Stderr, format{{.TypeName}}Token(tok))
		},
		OnAction: func(state int, action {{.TypeName}}Action, lookahead *tokens.Token) {
			if !traceStates {
				return
			}
			fmt.Fprintf(os.Stderr, "STATE %d %s on %s(%q)\n",
				state, format{{.TypeName}}Action(action), tokenTypeName{{.TypeName}}(lookahead), tokenLexeme{{.TypeName}}(lookahead))
		},
		OnStack: func(stateStack []int, nodeStack []*asts.ASTNode) {
			if !traceStack {
				return
			}
			fmt.Fprintf(os.Stderr, "STACK states=%s nodes=%s\n",
				format{{.TypeName}}IntStack(stateStack), format{{.TypeName}}NodeStack(nodeStack))
		},
	}
}

type {{.TypeName}}ActionKind int

const (
	{{.TypeName}}ActionShift {{.TypeName}}ActionKind = iota
	{{.TypeName}}ActionReduce
	{{.TypeName}}ActionAccept
)

type {{.TypeName}}Action struct {
	Kind   {{.TypeName}}ActionKind
	Target int
}

func format{{.TypeName}}Token(tok *tokens.Token) string {
	if tok == nil {
		return "TOK <nil>"
	}
	return fmt.Sprintf("TOK type=%s lexeme=%q line=%d col=%d",
		tok.Type, string(tok.Lexeme), tok.Location.LineNumber, tok.Location.ColumnNumber)
}

func tokenTypeName{{.TypeName}}(tok *tokens.Token) string {
	if tok == nil {
		return "<nil>"
	}
	return string(tok.Type)
}

func tokenLexeme{{.TypeName}}(tok *tokens.Token) string {
	if tok == nil {
		return ""
	}
	return string(tok.Lexeme)
}

func format{{.TypeName}}IntStack(stack []int) string {
	parts := make([]string, len(stack))
	for i, v := range stack {
		parts[i] = fmt.Sprintf("%d", v)
	}
	return "[" + strings.Join(parts, " ") + "]"
}

func format{{.TypeName}}NodeStack(stack []*asts.ASTNode) string {
	parts := make([]string, len(stack))
	for i, node := range stack {
		if node == nil {
			parts[i] = "<nil>"
			continue
		}
		parts[i] = string(node.Type)
	}
	return "[" + strings.Join(parts, " ") + "]"
}

func format{{.TypeName}}Action(action {{.TypeName}}Action) string {
	switch action.Kind {
	case {{.TypeName}}ActionShift:
		return fmt.Sprintf("shift(%d)", action.Target)
	case {{.TypeName}}ActionReduce:
		return fmt.Sprintf("reduce(%d)", action.Target)
	case {{.TypeName}}ActionAccept:
		return "accept"
	default:
		return "unknown"
	}
}

{{- if eq .HintMode "hints" }}

type {{.TypeName}}Production struct {
	lhs          asts.NodeType
	rhsCount     int
	hasHint      bool
	hasPassthrough bool
	parentIndex  int
	passthroughIndex int
	childIndices []int
	nodeType     asts.NodeType
}
{{- else }}

type {{.TypeName}}Production struct {
	lhs      asts.NodeType
	rhsCount int
}
{{- end }}

var {{.TypeName}}Actions = map[int]map[tokens.TokenType]{{.TypeName}}Action{
{{- range .Actions }}
	{{.State}}: {
{{- range .Entries }}
		{{.TerminalLiteral}}: {Kind: {{.KindLiteral}}{{if .HasTarget}}, Target: {{.Target}}{{end}}},
{{- end }}
	},
{{- end }}
}

var {{.TypeName}}Gotos = map[int]map[asts.NodeType]int{
{{- range .Gotos }}
	{{.State}}: {
{{- range .Entries }}
		{{.NontermLiteral}}: {{.Target}},
{{- end }}
	},
{{- end }}
}

var {{.TypeName}}Productions = []{{.TypeName}}Production{
{{- range .Productions }}
{{- if $.HintMode | eq "hints" }}
	{lhs: {{.LHSLiteral}}, rhsCount: {{.RHSCount}}, hasHint: {{.HasHint}}, hasPassthrough: {{.HasPassthrough}}, parentIndex: {{.ParentIndex}}, passthroughIndex: {{.PassthroughIndex}}, childIndices: {{childIndicesLiteral .ChildIndices}}{{if .NodeType}}, nodeType: asts.NodeType({{quote .NodeType}}){{end}}},
{{- else }}
	{lhs: {{.LHSLiteral}}, rhsCount: {{.RHSCount}}},
{{- end }}
{{- end }}
}
