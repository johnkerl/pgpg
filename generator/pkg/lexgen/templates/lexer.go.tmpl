package {{.PackageName}}

import (
	"fmt"
{{- if .HasIgnored }}
	"strings"
{{- end }}
	"unicode/utf8"

	manuallexers "github.com/johnkerl/pgpg/manual/pkg/lexers"
	"github.com/johnkerl/pgpg/manual/pkg/tokens"
)

type {{.TypeName}} struct {
	inputText     string
	inputLength   int
	tokenLocation *tokens.TokenLocation
}

var _ manuallexers.AbstractLexer = (*{{.TypeName}})(nil)

func New{{.TypeName}}(inputText string) manuallexers.AbstractLexer {
	return &{{.TypeName}}{
		inputText:     inputText,
		inputLength:   len(inputText),
		tokenLocation: tokens.NewTokenLocation(),
	}
}

func (lexer *{{.TypeName}}) Scan() *tokens.Token {
	for {
		if lexer.tokenLocation.ByteOffset >= lexer.inputLength {
			return tokens.NewEOFToken(lexer.tokenLocation)
		}

		startLocation := *lexer.tokenLocation
		scanLocation := *lexer.tokenLocation
		state := {{.TypeName}}StartState
		lastAcceptState := -1
		lastAcceptLocation := scanLocation

		for {
			if scanLocation.ByteOffset >= lexer.inputLength {
				break
			}
			r, width := lexer.peekRuneAt(scanLocation.ByteOffset)
			nextState, ok := {{.TypeName}}LookupTransition(state, r)
			if !ok {
				break
			}
			scanLocation.LocateRune(r, width)
			state = nextState
			if _, ok := {{.TypeName}}Actions[state]; ok {
				lastAcceptState = state
				lastAcceptLocation = scanLocation
			}
		}

		if lastAcceptState < 0 {
			r, _ := lexer.peekRuneAt(lexer.tokenLocation.ByteOffset)
			return tokens.NewErrorToken(fmt.Sprintf("lexer: unrecognized input %q", r), lexer.tokenLocation)
		}

		lexemeText := lexer.inputText[lexer.tokenLocation.ByteOffset:lastAcceptLocation.ByteOffset]
		lexeme := []rune(lexemeText)
		*lexer.tokenLocation = lastAcceptLocation
		tokenType := {{.TypeName}}Actions[lastAcceptState]
{{- if .HasIgnored }}
		if {{.TypeName}}IsIgnoredToken(tokenType) {
			continue
		}
{{- end }}
		return tokens.NewToken(lexeme, tokenType, &startLocation)
	}
}

func (lexer *{{.TypeName}}) peekRuneAt(byteOffset int) (rune, int) {
	r, width := utf8.DecodeRuneInString(lexer.inputText[byteOffset:])
	return r, width
}

func {{.TypeName}}LookupTransition(state int, r rune) (int, bool) {
	transitionsForState, ok := {{.TypeName}}Transitions[state]
	if !ok {
		return 0, false
	}
	for _, tr := range transitionsForState {
		if r < tr.from {
			return 0, false
		}
		if r >= tr.from && r <= tr.to {
			return tr.next, true
		}
	}
	return 0, false
}

{{- if .HasIgnored }}
func {{.TypeName}}IsIgnoredToken(tokenType tokens.TokenType) bool {
	return strings.HasPrefix(string(tokenType), "!")
}

{{- end }}
const {{.TypeName}}StartState = {{.StartState}}

type {{.TypeName}}RangeTransition struct {
	from rune
	to   rune
	next int
}

var {{.TypeName}}Transitions = map[int][]{{.TypeName}}RangeTransition{
{{- range .Transitions }}
	{{.State}}: {
{{- range .Ranges }}
		{from: {{printf "%q" .From}}, to: {{printf "%q" .To}}, next: {{.Next}}},
{{- end }}
	},
{{- end }}
}

var {{.TypeName}}Actions = map[int]tokens.TokenType{
{{- range .Actions }}
	{{.State}}: {{quote .TokenType}},
{{- end }}
}
